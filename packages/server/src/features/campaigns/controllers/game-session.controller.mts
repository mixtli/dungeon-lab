import { Request, Response } from 'express';
import { GameSessionService } from '../services/game-session.service.mjs';
import { logger } from '../../../utils/logger.mjs';
import {
  GetGameSessionsResponse,
  GetGameSessionResponse,
  GetCampaignSessionsResponse,
  CreateGameSessionRequest,
  CreateGameSessionResponse,
  UpdateGameSessionRequest,
  UpdateGameSessionResponse,
  DeleteGameSessionResponse,
  getGameSessionsQuerySchema,
  IGameSession,
  createGameSessionSchema,
  updateGameSessionSchema
} from '@dungeon-lab/shared/types/api/index.mjs';
import { ZodError } from 'zod';

// Custom error type guard
function isErrorWithMessage(error: unknown): error is { message: string } {
  return (
    typeof error === 'object' &&
    error !== null &&
    'message' in error &&
    typeof (error as { message: unknown }).message === 'string'
  );
}

export class GameSessionController {
  constructor(private gameSessionService: GameSessionService) {}

  async getGameSessions(
    req: Request,
    res: Response<GetGameSessionsResponse>
  ): Promise<Response<GetGameSessionsResponse> | void> {
    try {
      // Extract query parameters
      const { campaignId, status } = req.query;

      // Validate query parameters
      try {
        getGameSessionsQuerySchema.parse(req.query);
      } catch (validationError) {
        if (validationError instanceof ZodError) {
          return res.status(400).json({
            success: false,
            data: [],
            error: JSON.parse(validationError.message)
          });
        }
      }

      // Pass query parameters to the service
      const sessions = await this.gameSessionService.getGameSessions(req.session.user.id, {
        campaignId: campaignId as string,
        status: status as string
      });

      return res.json({
        success: true,
        data: sessions
      });
    } catch (error) {
      logger.error('Error getting game sessions:', error);
      return res.status(500).json({
        success: false,
        data: [],
        error: 'Failed to get game sessions'
      });
    }
  }

  async getGameSession(
    req: Request,
    res: Response<GetGameSessionResponse>
  ): Promise<Response<GetGameSessionResponse> | void> {
    try {
      const session = await this.gameSessionService.getGameSession(req.params.id);

      // Check if user has access to this session
      const hasAccess = await this.gameSessionService.checkUserPermission(
        req.params.id,
        req.session.user.id,
        req.session.user.isAdmin
      );

      if (!hasAccess) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      return res.json({
        success: true,
        data: session
      });
    } catch (error) {
      if (isErrorWithMessage(error) && error.message === 'Game session not found') {
        return res.status(404).json({
          success: false,
          error: 'Game session not found'
        });
      }
      logger.error('Error getting game session:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to get game session'
      });
    }
  }

  async getCampaignSessions(
    req: Request,
    res: Response<GetCampaignSessionsResponse>
  ): Promise<Response<GetCampaignSessionsResponse> | void> {
    try {
      const sessions = await this.gameSessionService.getCampaignSessions(req.params.campaignId);
      return res.json({
        success: true,
        data: sessions
      });
    } catch (error) {
      logger.error('Error getting campaign sessions:', error);
      return res.status(500).json({
        success: false,
        data: [],
        error: 'Failed to get campaign sessions'
      });
    }
  }

  async createGameSession(
    req: Request<object, object, CreateGameSessionRequest>,
    res: Response<CreateGameSessionResponse>
  ): Promise<Response<CreateGameSessionResponse> | void> {
    try {
      // Validate request body
      try {
        const validatedData = createGameSessionSchema.parse(req.body);

        // Create a session object with required fields that the service expects
        // The service will add the missing fields (gameMasterId, participants, etc.)
        const sessionData = {
          name: validatedData.name,
          campaignId: validatedData.campaignId,
          description: validatedData.description,
          status: validatedData.status || 'scheduled',
          participantIds: validatedData.participantIds || [],
          settings: validatedData.settings,
          // These will be set by the service but needed for type compatibility
          id: '', // Will be generated by MongoDB
          gameMasterId: '' // Will be set by service
        } as IGameSession;

        const session = await this.gameSessionService.createGameSession(
          sessionData,
          req.session.user.id
        );

        return res.status(201).json({
          success: true,
          data: session
        });
      } catch (validationError) {
        if (validationError instanceof ZodError) {
          return res.status(400).json({
            success: false,
            error: JSON.parse(validationError.message)
          });
        }
        throw validationError;
      }
    } catch (error) {
      if (isErrorWithMessage(error)) {
        if (error.message === 'Campaign not found') {
          return res.status(404).json({
            success: false,
            error: 'Campaign not found'
          });
        }
        if (error.message === 'Only the game master can create sessions') {
          return res.status(403).json({
            success: false,
            error: 'Only the game master can create sessions'
          });
        }
      }
      logger.error('Error creating game session:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to create game session'
      });
    }
  }

  async updateGameSession(
    req: Request<{ id: string }, object, UpdateGameSessionRequest>,
    res: Response<UpdateGameSessionResponse>
  ): Promise<Response<UpdateGameSessionResponse> | void> {
    try {
      // Check if user has permission to update
      const hasAccess = await this.gameSessionService.checkUserPermission(
        req.params.id,
        req.session.user.id,
        req.session.user.isAdmin
      );

      if (!hasAccess) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      // Validate request body
      try {
        const validatedData = updateGameSessionSchema.parse(req.body);

        // Create a partial session object with the fields from the request
        const updateData: Partial<IGameSession> = {
          ...(validatedData.name && { name: validatedData.name }),
          ...(validatedData.description && { description: validatedData.description }),
          ...(validatedData.status && { status: validatedData.status }),
          ...(validatedData.participantIds && { participantIds: validatedData.participantIds }),
          ...(validatedData.settings && { settings: validatedData.settings })
        };

        const updatedSession = await this.gameSessionService.updateGameSession(
          req.params.id,
          updateData,
          req.session.user.id
        );

        return res.json({
          success: true,
          data: updatedSession
        });
      } catch (validationError) {
        if (validationError instanceof ZodError) {
          return res.status(400).json({
            success: false,
            error: JSON.parse(validationError.message)
          });
        }
        throw validationError;
      }
    } catch (error) {
      if (isErrorWithMessage(error) && error.message === 'Game session not found') {
        return res.status(404).json({
          success: false,
          error: 'Game session not found'
        });
      }
      logger.error('Error updating game session:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to update game session'
      });
    }
  }

  async deleteGameSession(
    req: Request,
    res: Response<DeleteGameSessionResponse>
  ): Promise<Response<DeleteGameSessionResponse> | void> {
    try {
      // Check if user has permission to delete
      const hasAccess = await this.gameSessionService.checkUserPermission(
        req.params.id,
        req.session.user.id,
        req.session.user.isAdmin
      );

      if (!hasAccess) {
        return res.status(403).json({
          success: false,
          error: 'Access denied'
        });
      }

      await this.gameSessionService.deleteGameSession(req.params.id);
      return res.status(204).send();
    } catch (error) {
      if (isErrorWithMessage(error) && error.message === 'Game session not found') {
        return res.status(404).json({
          success: false,
          error: 'Game session not found'
        });
      }
      logger.error('Error deleting game session:', error);
      return res.status(500).json({
        success: false,
        error: 'Failed to delete game session'
      });
    }
  }
}
